# Тема: Секционирование

## Домашнее задание: "Триггеры, поддержка заполнения витрин: Создать триггер на таблице продаж, для поддержки данных в витрине в актуальном состоянии (вычисляющий при каждой продаже сумму и записывающий её в витрину)."

### 1. Создаем новый кластер main3
```sql
root@maxim-virtual-machine:/# sudo pg_createcluster 15 main3
Creating new PostgreSQL cluster 15/main3 ...
/usr/lib/postgresql/15/bin/initdb -D /var/lib/postgresql/15/main3 --auth-local peer --auth-host scram-sha-256 --no-instructions
The files belonging to this database system will be owned by user "postgres".
This user must also own the server process.

The database cluster will be initialized with this locale configuration:
  provider:    libc
  LC_COLLATE:  en_US.UTF-8
  LC_CTYPE:    en_US.UTF-8
  LC_MESSAGES: en_US.UTF-8
  LC_MONETARY: ru_RU.UTF-8
  LC_NUMERIC:  ru_RU.UTF-8
  LC_TIME:     ru_RU.UTF-8
The default database encoding has accordingly been set to "UTF8".
    The default text search configuration will be set to "english".

    Data page checksums are disabled.

    fixing permissions on existing directory /var/lib/postgresql/15/main3 ... ok
    creating subdirectories ... ok
    selecting dynamic shared memory implementation ... posix
    selecting default max_connections ... 100
    selecting default shared_buffers ... 128MB
    selecting default time zone ... Asia/Yekaterinburg
    creating configuration files ... ok
    running bootstrap script ... ok
    performing post-bootstrap initialization ... ok
    syncing data to disk ... ok
    Ver Cluster Port Status Owner    Data directory               Log file
15  main3   5434 down   postgres /var/lib/postgresql/15/main3 /var/log/postgresql/postgresql-15-main3.log

        
root@maxim-virtual-machine:/# pg_lsclusters
Ver Cluster Port Status Owner    Data directory               Log file
15  main    5432 online postgres /var/lib/postgresql/15/main  /var/log/postgresql/postgresql-15-main.log
15  main2   5433 online postgres /var/lib/postgresql/15/main2 /var/log/postgresql/postgresql-15-main2.log
15  main3   5434 down   postgres /var/lib/postgresql/15/main3 /var/log/postgresql/postgresql-15-main3.log

    
maxim@maxim-virtual-machine:/tmp$ sudo pg_ctlcluster 15 main3 start
[sudo] password for maxim: 
maxim@maxim-virtual-machine:/tmp$ pg_lsclusters
Ver Cluster Port Status Owner    Data directory               Log file
15  main    5432 online postgres /var/lib/postgresql/15/main  /var/log/postgresql/postgresql-15-main.log
15  main2   5433 online postgres /var/lib/postgresql/15/main2 /var/log/postgresql/postgresql-15-main2.log
15  main3   5434 online postgres /var/lib/postgresql/15/main3 /var/log/postgresql/postgresql-15-main3.log

```
#### 2.3 Скачиваем скрипт по ссылке https://disk.yandex.ru/d/l70AvknAepIJXQ в каталог tmp
```sql
root@maxim-virtual-machine:/tmp# ls
demo-big-20170815.sql
hw_triggers.sql
```
- Содержание скрипта:
```sql
-- ДЗ тема: триггеры, поддержка заполнения витрин

DROP SCHEMA IF EXISTS pract_functions CASCADE;
CREATE SCHEMA pract_functions;

SET search_path = pract_functions, publ

-- товары:
CREATE TABLE goods
(
    goods_id    integer PRIMARY KEY,
    good_name   varchar(63) NOT NULL,
    good_price  numeric(12, 2) NOT NULL CHECK (good_price > 0.0)
);
INSERT INTO goods (goods_id, good_name, good_price)
VALUES 	(1, 'Спички хозайственные', .50),
		(2, 'Автомобиль Ferrari FXX K', 185000000.01);

-- Продажи
CREATE TABLE sales
(
    sales_id    integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    good_id     integer REFERENCES goods (goods_id),
    sales_time  timestamp with time zone DEFAULT now(),
    sales_qty   integer CHECK (sales_qty > 0)
);

INSERT INTO sales (good_id, sales_qty) VALUES (1, 10), (1, 1), (1, 120), (2, 1);

-- отчет:
SELECT G.good_name, sum(G.good_price * S.sales_qty)
FROM goods G
INNER JOIN sales S ON S.good_id = G.goods_id
GROUP BY G.good_name;

-- с увеличением объёма данных отчет стал создаваться медленно
-- Принято решение денормализовать БД, создать таблицу
CREATE TABLE good_sum_mart
(
	good_name   varchar(63) NOT NULL PRIMARY KEY,
	sum_sale	numeric(16, 2)NOT NULL
);

-- Создать триггер (на таблице sales) для поддержки.
-- Подсказка: не забыть, что кроме INSERT есть еще UPDATE и DELETE

-- Чем такая схема (витрина+триггер) предпочтительнее отчета, создаваемого "по требованию" (кроме производительности)?
-- Подсказка: В реальной жизни возможны изменения цен.
```
#### 2.4 Загружаем скрипт в БД
```sql
root@maxim-virtual-machine:/tmp# sudo -u postgres psql -p 5434 -f hw_triggers.sql
DROP SCHEMA
CREATE SCHEMA
psql:hw_triggers.sql:14: ERROR:  syntax error at or near "CREATE"
LINE 4: CREATE TABLE goods
    ^
    psql:hw_triggers.sql:17: ERROR:  relation "goods" does not exist
    LINE 1: INSERT INTO goods (goods_id, good_name, good_price)
                ^
                psql:hw_triggers.sql:26: ERROR:  relation "goods" does not exist
                psql:hw_triggers.sql:28: ERROR:  relation "sales" does not exist
                LINE 1: INSERT INTO sales (good_id, sales_qty) VALUES (1, 10), (1, 1...
                    ^
psql:hw_triggers.sql:34: ERROR:  relation "goods" does not exist
LINE 2: FROM goods G
             ^
psql:hw_triggers.sql:42: ERROR:  relation "good_sum_mart" already exists
```
- При выполнении произошло множество ошибок по созданию сущностей в БД. Проблема оказалась в ошибке установки SEARCH_PATH - схема public была прописана не полностью и не хватала ';' в конце:
```sql
SET search_path = pract_functions, publ // <- ошибка!!!
```
- После исправления скрипт выполнился успешно:
```sql
root@maxim-virtual-machine:/tmp# sudo -u postgres psql -p 5434 -f hw_triggers.sql
DROP SCHEMA
CREATE SCHEMA
SET
CREATE TABLE
INSERT 0 2
CREATE TABLE
INSERT 0 4
        good_name         |     sum      
--------------------------+--------------
 Автомобиль Ferrari FXX K | 185000000.01
 Спички хозайственные     |        65.50
(2 rows)

CREATE TABLE
```
#### 2.5 Подключаемся к БД и пробуем получить все продажи
```sql
maxim@maxim-virtual-machine:/tmp$ sudo -u postgres psql -p 5434
[sudo] password for maxim: 
psql (15.6 (Ubuntu 15.6-1.pgdg22.04+1))
Type "help" for help.

postgres=# select * from sales;
ERROR:  relation "sales" does not exist
LINE 1: select * from sales;
```
- По какой-то причине не применились настройки SEARCH_PATH. Повторно применяем их и выполняем запрос.
```sql
postgres=# SET search_path = pract_functions, public;
SET
postgres=# select * from sales;
 sales_id | good_id |         sales_time          | sales_qty 
----------+---------+-----------------------------+-----------
        1 |       1 | 2024-05-04 12:17:51.6921+05 |        10
        2 |       1 | 2024-05-04 12:17:51.6921+05 |         1
        3 |       1 | 2024-05-04 12:17:51.6921+05 |       120
        4 |       2 | 2024-05-04 12:17:51.6921+05 |         1
(4 rows)
```
#### 2.6 Создаем функцию для поддержки витрины отображения суммы продаж по каждому товару в актуальном состоянии. (Константы для функций и триггеров https://postgrespro.ru/docs/postgrespro/15/plpgsql-trigger)
- Создаем функцию
```postgresql
create or replace function fn_sales_report_update() returns trigger as 
$body$
declare
    v_sales_qty integer;
    v_good_id   integer;
begin
    RAISE NOTICE 'Опрация над sales: TG_OP(%)', TG_OP;
    RAISE NOTICE 'Old row: OLD(%)', OLD;
    RAISE NOTICE 'New row: NEW(%)', NEW;
    
    if (TG_OP = 'INSERT') then
        v_sales_qty = NEW.sales_qty;
        v_good_id = NEW.good_id;
    elsif (TG_OP = 'UPDATE') then
        v_sales_qty = NEW.sales - OLD.sales_qty;
        v_good_id = OLD.good_id;
    elsif (TG_OP = 'DELETE') then
        v_sales_qty = 0 - OLD.sales_qty;
        v_good_id = OLD.good_id;
    end if;

    RAISE NOTICE 'Переопределены перепенные: v_sales_qty(%), v_good_id(%)', v_sales_qty, v_good_id;

    insert into good_sum_mart (good_name, sum_sale)
    select good_name, good_price * v_sales_qty
    from goods where goods_id = v_good_id
    on conflict on constraint good_name_unique
        do update set sum_sale = good_sum_mart.sum_sale + EXCLUDED.sum_sale
    where good_sum_mart.good_name = EXCLUDED.good_name;
    
    return null;
end;
$body$ language plpgsql;
```
- Добавим ограничение в good_sum_mart:
```postgresql
postgres=# alter table good_sum_mart add constraint good_name_unique unique (good_name);
```
- Создаем триггер
```postgresql
create trigger tr_sales_report_update after insert or update or delete on sales for each row execute function fn_sales_report_update();
```
#### 2.7 Проверки:
- Произведем чистку созданных таблиц:
```postgresql
truncate table sales;
truncate table good_sum_mart;
```
- Повторно заполним таблицу продаж:
```postgresql
postgres=# INSERT INTO sales (good_id, sales_qty) VALUES (1, 10), (1, 1), (1, 120), (2, 1);
NOTICE:  Опрация над sales: TG_OP(INSERT)
NOTICE:  Old row: OLD(<NULL>)
NOTICE:  New row: NEW((69,1,"2024-05-05 15:37:09.902889+05",10))
NOTICE:  Переопределены перепенные: v_sales_qty(10), v_good_id(1)
NOTICE:  Опрация над sales: TG_OP(INSERT)
NOTICE:  Old row: OLD(<NULL>)
NOTICE:  New row: NEW((70,1,"2024-05-05 15:37:09.902889+05",1))
NOTICE:  Переопределены перепенные: v_sales_qty(1), v_good_id(1)
NOTICE:  Опрация над sales: TG_OP(INSERT)
NOTICE:  Old row: OLD(<NULL>)
NOTICE:  New row: NEW((71,1,"2024-05-05 15:37:09.902889+05",120))
NOTICE:  Переопределены перепенные: v_sales_qty(120), v_good_id(1)
NOTICE:  Опрация над sales: TG_OP(INSERT)
NOTICE:  Old row: OLD(<NULL>)
NOTICE:  New row: NEW((72,2,"2024-05-05 15:37:09.902889+05",1))
NOTICE:  Переопределены перепенные: v_sales_qty(1), v_good_id(2)
INSERT 0 4
```
- Проверим старый отчет:
```postgresql
postgres=# SELECT G.good_name, sum(G.good_price * S.sales_qty)
FROM goods G
INNER JOIN sales S ON S.good_id = G.goods_id
GROUP BY G.good_name;
        good_name         |     sum      
--------------------------+--------------
 Автомобиль Ferrari FXX K | 185000000.01
 Спички хозайственные     |        65.50
(2 rows)
```
- Проверим работу триггера и функции - для построения нового отчета:
```postgresql
postgres=# select * from good_sum_mart;
        good_name         |   sum_sale   
--------------------------+--------------
 Спички хозайственные     |        65.50
 Автомобиль Ferrari FXX K | 185000000.01
(2 rows)
```
- Продадим еще парочку Ferrari
```postgresql
postgres=# insert into sales(good_id, sales_qty) values (2, 2);
NOTICE:  Опрация над sales: TG_OP(INSERT)
NOTICE:  Old row: OLD(<NULL>)
NOTICE:  New row: NEW((73,2,"2024-05-05 18:29:50.719331+05",2))
NOTICE:  Переопределены перепенные: v_sales_qty(2), v_good_id(2)
INSERT 0 1
```
- Проверим, обновился ли отчет:
```postgresql
postgres=# select * from good_sum_mart;
        good_name         |   sum_sale   
--------------------------+--------------
 Спички хозайственные     |        65.50
 Автомобиль Ferrari FXX K | 555000000.03
(2 rows)
```
- Отменим одну продажу Ferrari
```postgresql
postgres=# select * from sales;
 sales_id | good_id |          sales_time           | sales_qty 
----------+---------+-------------------------------+-----------
       69 |       1 | 2024-05-05 15:37:09.902889+05 |        10
       70 |       1 | 2024-05-05 15:37:09.902889+05 |         1
       71 |       1 | 2024-05-05 15:37:09.902889+05 |       120
       72 |       2 | 2024-05-05 15:37:09.902889+05 |         1
       73 |       2 | 2024-05-05 18:29:50.719331+05 |         2
(5 rows)

postgres=# delete from sales where good_id = 2 and sales_id = 72;
NOTICE:  Опрация над sales: TG_OP(DELETE)
NOTICE:  Old row: OLD((72,2,"2024-05-05 15:37:09.902889+05",1))
NOTICE:  New row: NEW(<NULL>)
NOTICE:  Переопределены перепенные: v_sales_qty(-1), v_good_id(2)
DELETE 1
postgres=# select * from sales;
 sales_id | good_id |          sales_time           | sales_qty 
----------+---------+-------------------------------+-----------
       69 |       1 | 2024-05-05 15:37:09.902889+05 |        10
       70 |       1 | 2024-05-05 15:37:09.902889+05 |         1
       71 |       1 | 2024-05-05 15:37:09.902889+05 |       120
       73 |       2 | 2024-05-05 18:29:50.719331+05 |         2
(4 rows)

postgres=# select * from good_sum_mart;
        good_name         |   sum_sale   
--------------------------+--------------
 Спички хозайственные     |        65.50
 Автомобиль Ferrari FXX K | 370000000.02
(2 rows)
```
#### 2.8 Задание с '*': Чем такая схема (витрина+триггер) предпочтительнее отчета, создаваемого "по требованию" (кроме производительности)?
- Актуальность данных: при формировании отчета может пройти какое-то время, данные в нем могут потерять актуальность при интенсивных продажах и большом количестве данных. В каких-то ситуациях это может иметь значение.
- Можно выводить данные на какой-нибудь дашборд, очень часто опрашивая табличку.
- Но в целом решение плохое - навешивать на все операции дополнительную логику. Это может привести к увеличению длительности блокировок и в целом негативно сказаться на производительности, при частых манипуляциях с данными.