# Тема: "Оптимизация запросов на демонстрационной базе 'Авиаперевозки'".

### 1. Подготовительные работы:

- Создана VM со следующими характеристиками:

```text
Модель оборудования:      VMware, Inc. VMware Virtual Platform
Оперативная память (RAM): 8 Gb
Процессор:                Intel® Core™ i9-9880H CPU @ 2.30GHz × 8 (для VM было выделено 8 физических ядер)
Хранилище SSD:            60GB
ОС:                       Ubuntu 22.04.4 LTS
```

- Найден и получен backup демонстрационной БД "Авиаперевозки":

```text
Описание на Github:     https://github.com/neondatabase/postgres-sample-dbs?tab=readme-ov-file#postgres-air-database
Описание на сайте:      https://neon.tech/docs/import/import-sample-data#postgres-air-database
Файлы БД в GoogleDrive: https://drive.google.com/drive/folders/13F7M80Kf_somnjb-mTYAnh1hW1Y_g4kJ
```

- Установлен кластер PostgreSQL 15
- Созданы БД и пользователь:

```postgresql
axim@maxim-virtual-machine:~$ pg_lsclusters
Ver
Cluster Port Status Owner    Data directory              Log file
15  main    5432 online postgres /var/lib/postgresql/15/main /var/log/postgresql/postgresql-15-main.log
maxim@maxim-virtual-machine:~$  sudo -u postgres createuser mplotnikov
maxim@maxim-virtual-machine:~$  sudo -u postgres psql
[sudo] пароль для maxim: 
psql (15.7 (Ubuntu 15.7-1.pgdg22.04+1))
Type "help" for help.

postgres=#
CREATE DATABASE postgres_air;
CREATE DATABASE
    postgres=#
\c postgres_air
You are now connected to database "postgres_air" as user "postgres".
postgres_air=#
alter user mplotnikov with encrypted password 'mplotnikov';
ALTER ROLE
    postgres_air=# grant all privileges on database postgres_air to mplotnikov;
GRANT
```

- Развернут backup демонстрационной БД

```text
maxim@maxim-virtual-machine:/tmp/demo_db_backup$  pg_restore -d postgres://mplotnikov:mplotnikov@localhost/postgres_air -Fc postgres_air.backup -c -v --no-owner --no-privileges
pg_restore: подключение к базе данных для восстановления
pg_restore: удаляется FK CONSTRAINT phone phone_account_id_fk
pg_restore: при обработке оглавления:
pg_restore: из записи оглавления 3160; 2606 60260 FK CONSTRAINT phone phone_account_id_fk hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "phone_account_id_fk" в таблице "phone" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.phone DROP CONSTRAINT phone_account_id_fk;
pg_restore: удаляется FK CONSTRAINT boarding_pass passenger_id_fk
pg_restore: из записи оглавления 3150; 2606 60255 FK CONSTRAINT boarding_pass passenger_id_fk postgres
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "passenger_id_fk" в таблице "boarding_pass" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.boarding_pass DROP CONSTRAINT passenger_id_fk;
pg_restore: удаляется FK CONSTRAINT passenger pass_frequent_flyer_id_fk
pg_restore: из записи оглавления 3159; 2606 60250 FK CONSTRAINT passenger pass_frequent_flyer_id_fk hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "pass_frequent_flyer_id_fk" в таблице "passenger" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.passenger DROP CONSTRAINT pass_frequent_flyer_id_fk;
pg_restore: удаляется FK CONSTRAINT passenger pass_booking_id_fk
pg_restore: из записи оглавления 3158; 2606 60245 FK CONSTRAINT passenger pass_booking_id_fk hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "pass_booking_id_fk" в таблице "passenger" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.passenger DROP CONSTRAINT pass_booking_id_fk;
pg_restore: удаляется FK CONSTRAINT passenger pass_account_id_fk
pg_restore: из записи оглавления 3157; 2606 60240 FK CONSTRAINT passenger pass_account_id_fk hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "pass_account_id_fk" в таблице "passenger" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.passenger DROP CONSTRAINT pass_account_id_fk;
pg_restore: удаляется FK CONSTRAINT account frequent_flyer_id_fk
pg_restore: из записи оглавления 3148; 2606 60235 FK CONSTRAINT account frequent_flyer_id_fk hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "frequent_flyer_id_fk" в таблице "account" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.account DROP CONSTRAINT frequent_flyer_id_fk;
pg_restore: удаляется FK CONSTRAINT booking_leg flight_id_fk
pg_restore: из записи оглавления 3153; 2606 60230 FK CONSTRAINT booking_leg flight_id_fk hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "flight_id_fk" в таблице "booking_leg" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.booking_leg DROP CONSTRAINT flight_id_fk;
pg_restore: удаляется FK CONSTRAINT flight departure_airport_fk
pg_restore: из записи оглавления 3156; 2606 60225 FK CONSTRAINT flight departure_airport_fk hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "departure_airport_fk" в таблице "flight" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.flight DROP CONSTRAINT departure_airport_fk;
pg_restore: удаляется FK CONSTRAINT boarding_pass booking_leg_id_fk
pg_restore: из записи оглавления 3149; 2606 60220 FK CONSTRAINT boarding_pass booking_leg_id_fk postgres
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "booking_leg_id_fk" в таблице "boarding_pass" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.boarding_pass DROP CONSTRAINT booking_leg_id_fk;
pg_restore: удаляется FK CONSTRAINT booking_leg booking_id_fk
pg_restore: из записи оглавления 3152; 2606 60215 FK CONSTRAINT booking_leg booking_id_fk hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "booking_id_fk" в таблице "booking_leg" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.booking_leg DROP CONSTRAINT booking_id_fk;
pg_restore: удаляется FK CONSTRAINT booking booking_account_id_fk
pg_restore: из записи оглавления 3151; 2606 60210 FK CONSTRAINT booking booking_account_id_fk hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "booking_account_id_fk" в таблице "booking" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.booking DROP CONSTRAINT booking_account_id_fk;
pg_restore: удаляется FK CONSTRAINT flight arrival_airport_fk
pg_restore: из записи оглавления 3155; 2606 60205 FK CONSTRAINT flight arrival_airport_fk hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "arrival_airport_fk" в таблице "flight" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.flight DROP CONSTRAINT arrival_airport_fk;
pg_restore: удаляется FK CONSTRAINT flight aircraft_code_fk
pg_restore: из записи оглавления 3154; 2606 60200 FK CONSTRAINT flight aircraft_code_fk hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "aircraft_code_fk" в таблице "flight" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.flight DROP CONSTRAINT aircraft_code_fk;
pg_restore: удаляется CONSTRAINT phone phone_pkey
pg_restore: из записи оглавления 3147; 2606 60199 CONSTRAINT phone phone_pkey hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "phone_pkey" в таблице "phone" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.phone DROP CONSTRAINT phone_pkey;
pg_restore: удаляется CONSTRAINT passenger passenger_pkey
pg_restore: из записи оглавления 3143; 2606 60197 CONSTRAINT passenger passenger_pkey hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "passenger_pkey" в таблице "passenger" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.passenger DROP CONSTRAINT passenger_pkey;
pg_restore: удаляется CONSTRAINT frequent_flyer frequent_flyer_pkey
pg_restore: из записи оглавления 3145; 2606 60195 CONSTRAINT frequent_flyer frequent_flyer_pkey hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "frequent_flyer_pkey" в таблице "frequent_flyer" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.frequent_flyer DROP CONSTRAINT frequent_flyer_pkey;
pg_restore: удаляется CONSTRAINT flight flight_pkey
pg_restore: из записи оглавления 3141; 2606 60193 CONSTRAINT flight flight_pkey hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "flight_pkey" в таблице "flight" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.flight DROP CONSTRAINT flight_pkey;
pg_restore: удаляется CONSTRAINT booking booking_pkey
pg_restore: из записи оглавления 3137; 2606 60191 CONSTRAINT booking booking_pkey hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "booking_pkey" в таблице "booking" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.booking DROP CONSTRAINT booking_pkey;
pg_restore: удаляется CONSTRAINT booking_leg booking_leg_pkey
pg_restore: из записи оглавления 3139; 2606 60189 CONSTRAINT booking_leg booking_leg_pkey hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "booking_leg_pkey" в таблице "booking_leg" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.booking_leg DROP CONSTRAINT booking_leg_pkey;
pg_restore: удаляется CONSTRAINT booking booking_booking_ref_key
pg_restore: из записи оглавления 3135; 2606 60185 CONSTRAINT booking booking_booking_ref_key hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "booking_booking_ref_key" в таблице "booking" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.booking DROP CONSTRAINT booking_booking_ref_key;
pg_restore: удаляется CONSTRAINT boarding_pass boarding_pass_pkey
pg_restore: из записи оглавления 3133; 2606 60183 CONSTRAINT boarding_pass boarding_pass_pkey postgres
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "boarding_pass_pkey" в таблице "boarding_pass" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.boarding_pass DROP CONSTRAINT boarding_pass_pkey;
pg_restore: удаляется CONSTRAINT airport airport_pkey
pg_restore: из записи оглавления 3131; 2606 60181 CONSTRAINT airport airport_pkey hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "airport_pkey" в таблице "airport" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.airport DROP CONSTRAINT airport_pkey;
pg_restore: удаляется CONSTRAINT aircraft aircraft_pkey
pg_restore: из записи оглавления 3129; 2606 60179 CONSTRAINT aircraft aircraft_pkey hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "aircraft_pkey" в таблице "aircraft" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.aircraft DROP CONSTRAINT aircraft_pkey;
pg_restore: удаляется CONSTRAINT account account_pkey
pg_restore: из записи оглавления 3127; 2606 60177 CONSTRAINT account account_pkey hettie
pg_restore: ошибка: could not execute query: ОШИБКА:  ограничение "account_pkey" в таблице "account" не существует
Выполнялась команда: ALTER TABLE ONLY postgres_air.account DROP CONSTRAINT account_pkey;
pg_restore: удаляется DEFAULT phone phone_id
pg_restore: удаляется DEFAULT passenger passenger_id
pg_restore: удаляется DEFAULT frequent_flyer frequent_flyer_id
pg_restore: удаляется DEFAULT flight flight_id
pg_restore: удаляется DEFAULT booking_leg booking_leg_id
pg_restore: удаляется DEFAULT account account_id
pg_restore: удаляется SEQUENCE phone_phone_id_seq
pg_restore: удаляется TABLE phone
pg_restore: удаляется SEQUENCE passenger_passenger_id_seq
pg_restore: удаляется TABLE passenger
pg_restore: удаляется SEQUENCE frequent_flyer_frequent_flyer_id_seq
pg_restore: удаляется TABLE frequent_flyer
pg_restore: удаляется SEQUENCE flight_flight_id_seq
pg_restore: удаляется TABLE flight
pg_restore: удаляется SEQUENCE booking_number
pg_restore: удаляется SEQUENCE booking_leg_booking_leg_id_seq
pg_restore: удаляется TABLE booking_leg
pg_restore: удаляется TABLE booking
pg_restore: удаляется TABLE boarding_pass
pg_restore: удаляется SEQUENCE boarding_pass_pass_id_seq
pg_restore: удаляется TABLE airport
pg_restore: удаляется TABLE aircraft
pg_restore: удаляется SEQUENCE account_account_id_seq
pg_restore: удаляется TABLE account
pg_restore: удаляется SCHEMA postgres_air
pg_restore: создаётся SCHEMA "postgres_air"
pg_restore: создаётся TABLE "postgres_air.account"
pg_restore: создаётся SEQUENCE "postgres_air.account_account_id_seq"
pg_restore: создаётся SEQUENCE OWNED BY "postgres_air.account_account_id_seq"
pg_restore: создаётся TABLE "postgres_air.aircraft"
pg_restore: создаётся TABLE "postgres_air.airport"
pg_restore: создаётся SEQUENCE "postgres_air.boarding_pass_pass_id_seq"
pg_restore: создаётся TABLE "postgres_air.boarding_pass"
pg_restore: создаётся TABLE "postgres_air.booking"
pg_restore: создаётся TABLE "postgres_air.booking_leg"
pg_restore: создаётся SEQUENCE "postgres_air.booking_leg_booking_leg_id_seq"
pg_restore: создаётся SEQUENCE OWNED BY "postgres_air.booking_leg_booking_leg_id_seq"
pg_restore: создаётся SEQUENCE "postgres_air.booking_number"
pg_restore: создаётся TABLE "postgres_air.flight"
pg_restore: создаётся SEQUENCE "postgres_air.flight_flight_id_seq"
pg_restore: создаётся SEQUENCE OWNED BY "postgres_air.flight_flight_id_seq"
pg_restore: создаётся TABLE "postgres_air.frequent_flyer"
pg_restore: создаётся SEQUENCE "postgres_air.frequent_flyer_frequent_flyer_id_seq"
pg_restore: создаётся SEQUENCE OWNED BY "postgres_air.frequent_flyer_frequent_flyer_id_seq"
pg_restore: создаётся TABLE "postgres_air.passenger"
pg_restore: создаётся SEQUENCE "postgres_air.passenger_passenger_id_seq"
pg_restore: создаётся SEQUENCE OWNED BY "postgres_air.passenger_passenger_id_seq"
pg_restore: создаётся TABLE "postgres_air.phone"
pg_restore: создаётся SEQUENCE "postgres_air.phone_phone_id_seq"
pg_restore: создаётся SEQUENCE OWNED BY "postgres_air.phone_phone_id_seq"
pg_restore: создаётся DEFAULT "postgres_air.account account_id"
pg_restore: создаётся DEFAULT "postgres_air.booking_leg booking_leg_id"
pg_restore: создаётся DEFAULT "postgres_air.flight flight_id"
pg_restore: создаётся DEFAULT "postgres_air.frequent_flyer frequent_flyer_id"
pg_restore: создаётся DEFAULT "postgres_air.passenger passenger_id"
pg_restore: создаётся DEFAULT "postgres_air.phone phone_id"
pg_restore: обрабатываются данные таблицы "postgres_air.account"
pg_restore: обрабатываются данные таблицы "postgres_air.aircraft"
pg_restore: обрабатываются данные таблицы "postgres_air.airport"
pg_restore: обрабатываются данные таблицы "postgres_air.boarding_pass"
pg_restore: обрабатываются данные таблицы "postgres_air.booking"
pg_restore: обрабатываются данные таблицы "postgres_air.booking_leg"
pg_restore: обрабатываются данные таблицы "postgres_air.flight"
pg_restore: обрабатываются данные таблицы "postgres_air.frequent_flyer"
pg_restore: обрабатываются данные таблицы "postgres_air.passenger"
pg_restore: обрабатываются данные таблицы "postgres_air.phone"
pg_restore: выполняется SEQUENCE SET account_account_id_seq
pg_restore: выполняется SEQUENCE SET boarding_pass_pass_id_seq
pg_restore: выполняется SEQUENCE SET booking_leg_booking_leg_id_seq
pg_restore: выполняется SEQUENCE SET booking_number
pg_restore: выполняется SEQUENCE SET flight_flight_id_seq
pg_restore: выполняется SEQUENCE SET frequent_flyer_frequent_flyer_id_seq
pg_restore: выполняется SEQUENCE SET passenger_passenger_id_seq
pg_restore: выполняется SEQUENCE SET phone_phone_id_seq
pg_restore: создаётся CONSTRAINT "postgres_air.account account_pkey"
pg_restore: создаётся CONSTRAINT "postgres_air.aircraft aircraft_pkey"
pg_restore: создаётся CONSTRAINT "postgres_air.airport airport_pkey"
pg_restore: создаётся CONSTRAINT "postgres_air.boarding_pass boarding_pass_pkey"
pg_restore: создаётся CONSTRAINT "postgres_air.booking booking_booking_ref_key"
pg_restore: создаётся CONSTRAINT "postgres_air.booking_leg booking_leg_pkey"
pg_restore: создаётся CONSTRAINT "postgres_air.booking booking_pkey"
pg_restore: создаётся CONSTRAINT "postgres_air.flight flight_pkey"
pg_restore: создаётся CONSTRAINT "postgres_air.frequent_flyer frequent_flyer_pkey"
pg_restore: создаётся CONSTRAINT "postgres_air.passenger passenger_pkey"
pg_restore: создаётся CONSTRAINT "postgres_air.phone phone_pkey"
pg_restore: создаётся FK CONSTRAINT "postgres_air.flight aircraft_code_fk"
pg_restore: создаётся FK CONSTRAINT "postgres_air.flight arrival_airport_fk"
pg_restore: создаётся FK CONSTRAINT "postgres_air.booking booking_account_id_fk"
pg_restore: создаётся FK CONSTRAINT "postgres_air.booking_leg booking_id_fk"
pg_restore: создаётся FK CONSTRAINT "postgres_air.boarding_pass booking_leg_id_fk"
pg_restore: создаётся FK CONSTRAINT "postgres_air.flight departure_airport_fk"
pg_restore: создаётся FK CONSTRAINT "postgres_air.booking_leg flight_id_fk"
pg_restore: создаётся FK CONSTRAINT "postgres_air.account frequent_flyer_id_fk"
pg_restore: создаётся FK CONSTRAINT "postgres_air.passenger pass_account_id_fk"
pg_restore: создаётся FK CONSTRAINT "postgres_air.passenger pass_booking_id_fk"
pg_restore: создаётся FK CONSTRAINT "postgres_air.passenger pass_frequent_flyer_id_fk"
pg_restore: создаётся FK CONSTRAINT "postgres_air.boarding_pass passenger_id_fk"
pg_restore: создаётся FK CONSTRAINT "postgres_air.phone phone_account_id_fk"
pg_restore: предупреждение: при восстановлении проигнорировано ошибок: 24
```

- Диаграмма связей таблиц: ![postgres_air_tables_diagram.png](postgres_air_tables_diagram.png)
  Эта база данных содержит несколько таблиц:
    - клиенты (таблица account),
    - Частота полетов клиентов (таблица frequent_flyer)
    - Клиентские брони авиабилетов (таблица booking)
        - Каждое бронирование состоит из одного или нескольких перелетов (таблица booking_leg)
        - каждый этап соответствует конкретному прямому рейсу в определенную дату (таблица flight) между двумя
          аэропортами (таблица airport)
    - Пассажиры (таблица passenger)
    - За каждым рейсом закреплено воздушное судно (таблица aircraft).
    - Для каждого пассажира на каждый перелет имеется посадочный талон (таблица boarding_pass).
- Количество записей в таблицах:

```postgresql
--select count(*) from postgres_air.account; --(257333)
--select count(*) from postgres_air.aircraft; --(12)
--select count(*) from postgres_air.airport; --(666)
--select count(*) from postgres_air.boarding_pass; --(25293491)
--select count(*) from postgres_air.booking_leg; --(17893566)
--select count(*) from postgres_air.flight; --(683176)
--select count(*) from postgres_air.frequent_flyer; --(128346)
--explain analyze select count(*) from postgres_air.passenger; --(16313693)
select count(*)
from postgres_air.booking b;
    (5643216)
select count(*)
from postgres_air.phone; --(407444)
```

- Размер БД после восстановления:

```postgresql
postgres_air=#
SELECT pg_size_pretty(pg_database_size('postgres_air'));
9768 MB
```

### 2. Формирование запроса:

- Временные промежутки броней

```postgresql
postgres_air=#
select min(b.update_ts), max(b.update_ts)
from postgres_air.booking b;
min              |             max              
-------------------------------+------------------------------
 2020-03-10 08:38:00.114908+05 | 2020-08-18 08:08:30.30921+05
(1 row)
```

- После выполнения каждого запроса ниже - сервер рестартовался для сброса кешей
- Запрос данных о рейсах пассажиров на майские праздники, сгенерированный ORM, где $1 - '2020-04-30', а $2 - '2020-05-12';

```postgresql
select passenger0_.passenger_id as passenge1_1_,
       passenger0_.first_name   as first_na2_1_,
       passenger0_.last_name    as last_nam3_1_,
       (select flight3_.flight_no
        from postgres_air.booking_leg as booking_leg2_
                 left join postgres_air.flight as flight3_ on ooking_leg2_.flight_id = flight3_.flight_id
        where booking1_.booking_id is not null
          and booking1_.booking_id = postgres_air2_.booking_id
        limit 1)                as flight_n4_1_
from postgres_air.passenger as passenger0_
         left join postgres_air.booking as booking1_ on passenger0_.booking_id = booking1_.booking_id
WHERE booking1_.update_ts between $1 and $2;
```

- Приведем запрос в более читаемый вид, и получим план запроса на только что развернутом сервере Postgres.
```postgresql
postgres_air=# explain select p.passenger_id as "Идентификатор пассажира",
                              p.first_name   as "Имя",
                              p.last_name    as "Фамилия",
                              (select f.flight_no
                               from postgres_air.booking_leg as bl
                                        left join postgres_air.flight as f on bl.flight_id = f.flight_id
                               where b.booking_id is not null
                                 and b.booking_id = bl.booking_id
                               limit 1)      as "Номер самолета"
                       from postgres_air.passenger as p
                                left join postgres_air.booking as b on p.booking_id = b.booking_id
                       WHERE b.update_ts between '2020-04-30'::date and '2020-05-12'::date;
QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Gather  (cost=126513.89..42131952931.92 rows=1541289 width=48)
   Workers Planned: 2
   ->  Parallel Hash Join  (cost=125513.89..463509.65 rows=642204 width=24)
         Hash Cond: (p.booking_id = b.booking_id)
         ->  Parallel Seq Scan on passenger p  (cost=0.00..239624.04 rows=6797604 width=20)
         ->  Parallel Hash  (cost=121869.10..121869.10 rows=222143 width=8)
               ->  Parallel Seq Scan on booking b  (cost=0.00..121869.10 rows=222143 width=8)
                     Filter: ((update_ts >= '2020-04-30'::date) AND (update_ts <= '2020-05-12'::date))
   SubPlan 1
     ->  Limit  (cost=0.42..27335.13 rows=1 width=4)
           ->  Result  (cost=0.42..355351.58 rows=13 width=4)
                 One-Time Filter: (b.booking_id IS NOT NULL)
                 ->  Nested Loop Left Join  (cost=0.42..355351.58 rows=13 width=4)
                       ->  Seq Scan on booking_leg bl  (cost=0.00..355241.70 rows=13 width=4)
                             Filter: (b.booking_id = booking_id)
                       ->  Index Scan using flight_pkey on flight f  (cost=0.42..8.44 rows=1 width=8)
                             Index Cond: (flight_id = bl.flight_id)
 JIT:
   Functions: 23
   Options: Inlining true, Optimization true, Expressions true, Deforming true
(20 строк)
```
- План запроса показал очень большую стоимость, запрос не завершился за 20 мин.
- Выполним калькуляцию оптимальной конфигруции кластера Postgres 15, исходя из конфигурации VM с помощью
  PGTUNE (https://pgtune.leopard.in.ua/):

```text
-- DB Version: 15
-- OS Type: linux
-- DB Type: desktop
-- Total Memory (RAM): 8 GB
-- CPUs num: 8
-- Connections num: 100
-- Data Storage: ssd

ALTER SYSTEM SET
 max_connections = '100';
ALTER SYSTEM SET
 shared_buffers = '512MB';
ALTER SYSTEM SET
 effective_cache_size = '2GB';
ALTER SYSTEM SET
 maintenance_work_mem = '512MB';
ALTER SYSTEM SET
 checkpoint_completion_target = '0.9';
ALTER SYSTEM SET
 wal_buffers = '16MB';
ALTER SYSTEM SET
 default_statistics_target = '100';
ALTER SYSTEM SET
 random_page_cost = '1.1';
ALTER SYSTEM SET
 effective_io_concurrency = '200';
ALTER SYSTEM SET
 work_mem = '1092kB';
ALTER SYSTEM SET
 huge_pages = 'off';
ALTER SYSTEM SET
 min_wal_size = '100MB';
ALTER SYSTEM SET
 max_wal_size = '2GB';
ALTER SYSTEM SET
 max_worker_processes = '8';
ALTER SYSTEM SET
 max_parallel_workers_per_gather = '4';
ALTER SYSTEM SET
 max_parallel_workers = '8';
ALTER SYSTEM SET
 max_parallel_maintenance_workers = '4';
```
- После изменения конфигурации вновь построим план запроса и проверим что изменилось
```postgresql
postgres_air=# explain select p.passenger_id as "Идентификатор пассажира",
                              p.first_name   as "Имя",
                              p.last_name    as "Фамилия",
                              (select f.flight_no
                               from postgres_air.booking_leg as bl
                                        left join postgres_air.flight as f on bl.flight_id = f.flight_id
                               where b.booking_id is not null
                                 and b.booking_id = bl.booking_id
                               limit 1)      as "Номер самолета"
                       from postgres_air.passenger as p
                                left join postgres_air.booking as b on p.booking_id = b.booking_id
                       WHERE b.update_ts between '2020-04-30'::date and '2020-05-12'::date;
QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Gather  (cost=110948.13..42122931351.06 rows=1537239 width=48)
   Workers Planned: 4
   ->  Parallel Hash Join  (cost=109948.13..381405.00 rows=385322 width=24)
         Hash Cond: (p.booking_id = b.booking_id)
         ->  Parallel Seq Scan on passenger p  (cost=0.00..212433.62 rows=4078562 width=20)
         ->  Parallel Hash  (cost=107761.06..107761.06 rows=133286 width=8)
               ->  Parallel Seq Scan on booking b  (cost=0.00..107761.06 rows=133286 width=8)
                     Filter: ((update_ts >= '2020-04-30'::date) AND (update_ts <= '2020-05-12'::date))
   SubPlan 1
     ->  Limit  (cost=0.42..27329.33 rows=1 width=4)
           ->  Result  (cost=0.42..355276.18 rows=13 width=4)
                 One-Time Filter: (b.booking_id IS NOT NULL)
                 ->  Nested Loop Left Join  (cost=0.42..355276.18 rows=13 width=4)
                       ->  Seq Scan on booking_leg bl  (cost=0.00..355241.70 rows=13 width=4)
                             Filter: (b.booking_id = booking_id)
                       ->  Index Scan using flight_pkey on flight f  (cost=0.42..2.64 rows=1 width=8)
                             Index Cond: (flight_id = bl.flight_id)
 JIT:
   Functions: 23
   Options: Inlining true, Optimization true, Expressions true, Deforming true
(20 rows)
```
- Слегка уменьшился нижний и верхний пороги стоимости запроса, но запрос также не завершился и за 20 мин.

- Далее вспоминаем о частоте сброса памяти из RAM в SWAP. Для PostgreSQL рекомендовано от 1 до 5.
```postgresql
maxim@maxim-virtual-machine:~$ cat /proc/sys/vm/swappiness
60
maxim@maxim-virtual-machine:~$ sysctl vm.swappiness=5
sysctl: permission denied on key "vm.swappiness", ignoring
maxim@maxim-virtual-machine:~$ sudo sysctl vm.swappiness=5
[sudo] пароль для maxim: 
vm.swappiness = 5
maxim@maxim-virtual-machine:~$ sudo echo 'vm.swappiness=5' >> /etc/sysctl.conf
bash: /etc/sysctl.conf: Отказано в доступе
maxim@maxim-virtual-machine:~$ echo 'vm.swappiness=5' >> /etc/sysctl.conf
bash: /etc/sysctl.conf: Отказано в доступе
maxim@maxim-virtual-machine:~$ sudo -i
root@maxim-virtual-machine:~# echo 'vm.swappiness=5' >> /etc/sysctl.conf
```
- Настройка эффекта не дала.
- Попробуем подтюнить сам запрос, избавится от вложенности
```postgresql
postgres_air=# explain analyze select p.passenger_id as "Идентификатор пассажира",
                                      p.first_name   as "Имя",
                                      p.last_name    as "Фамилия",
                                      f.flight_no    as "Номер самолета"
                               from postgres_air.booking as b
                                        left join postgres_air.passenger as p on p.booking_id = b.booking_id
                                        left join postgres_air.booking_leg as bl on b.booking_id = bl.booking_id
                                        left join postgres_air.flight as f on bl.flight_id = f.flight_id
                               where b.update_ts between '2020-04-30'::date and '2020-05-12'::date;
QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather  (cost=554095.24..1211745.00 rows=4887159 width=20) (actual time=113599.740..118364.914 rows=4810062 loops=1)
   Workers Planned: 4
   Workers Launched: 4
   ->  Parallel Hash Left Join  (cost=553095.24..722029.10 rows=1221790 width=20) (actual time=113567.456..116915.522 rows=962012 loops=5)
         Hash Cond: (b.booking_id = p.booking_id)
         ->  Parallel Hash Left Join  (cost=265781.59..400465.27 rows=422626 width=12) (actual time=81095.108..81155.749 rows=332654 loops=5)
               Hash Cond: (bl.flight_id = f.flight_id)
               ->  Parallel Hash Left Join  (cost=249697.82..378032.09 rows=422626 width=12) (actual time=49983.787..50244.604 rows=332654 loops=5)
                     Hash Cond: (b.booking_id = bl.booking_id)
                     ->  Parallel Seq Scan on booking b  (cost=0.00..107761.06 rows=133286 width=8) (actual time=4020.048..10590.801 rows=105557 loops=5)
                           Filter: ((update_ts >= '2020-04-30'::date) AND (update_ts <= '2020-05-12'::date))
                           Rows Removed by Filter: 1023086
                     ->  Parallel Hash  (cost=176305.14..176305.14 rows=4473414 width=8) (actual time=23951.590..23951.591 rows=3578713 loops=5)
                           Buckets: 65536  Batches: 512  Memory Usage: 1952kB
                           ->  Parallel Seq Scan on booking_leg bl  (cost=0.00..176305.14 rows=4473414 width=8) (actual time=0.240..7063.033 rows=3578713 loops=5)
               ->  Parallel Hash  (cost=11413.57..11413.57 rows=284657 width=8) (actual time=30777.579..30777.580 rows=136635 loops=5)
                     Buckets: 65536  Batches: 32  Memory Usage: 1568kB
                     ->  Parallel Seq Scan on flight f  (cost=0.00..11413.57 rows=284657 width=8) (actual time=1.658..6732.713 rows=136635 loops=5)
         ->  Parallel Hash  (cost=212433.62..212433.62 rows=4078562 width=20) (actual time=31987.642..31987.643 rows=3262739 loops=5)
               Buckets: 65536  Batches: 1024  Memory Usage: 1504kB
               ->  Parallel Seq Scan on passenger p  (cost=0.00..212433.62 rows=4078562 width=20) (actual time=419.230..9889.462 rows=3262739 loops=5)
 Planning Time: 31.146 ms
 JIT:
   Functions: 140
   Options: Inlining true, Optimization true, Expressions true, Deforming true
   Timing: Generation 7.662 ms, Inlining 950.645 ms, Optimization 528.970 ms, Emission 617.816 ms, Total 2105.093 ms
 Execution Time: 118523.481 ms
(27 rows)
```
- Нижний порог стоимости увеличился в 5 раз, но верхний порог стоимости уменьшился в 34762 раза. Фактическое время выполнения - Query complete 00:01:28.866.

- Попробуем создать индексы:
```postgresql
create index booking_update_ts_idx on postgres_air.booking(update_ts);
```
- Проверяем план
```postgresql
 Gather  (cost=554095.24..1211745.00 rows=4887159 width=20) (actual time=60305.773..95948.671 rows=4810062 loops=1)
   Workers Planned: 4
   Workers Launched: 4
   ->  Parallel Hash Left Join  (cost=553095.24..722029.10 rows=1221790 width=20) (actual time=60278.979..81981.991 rows=962012 loops=5)
         Hash Cond: (b.booking_id = p.booking_id)
         ->  Parallel Hash Left Join  (cost=265781.59..400465.27 rows=422626 width=12) (actual time=49748.472..49875.806 rows=332654 loops=5)
               Hash Cond: (bl.flight_id = f.flight_id)
               ->  Parallel Hash Left Join  (cost=249697.82..378032.09 rows=422626 width=12) (actual time=39702.838..40951.897 rows=332654 loops=5)
                     Hash Cond: (b.booking_id = bl.booking_id)
                     ->  Parallel Seq Scan on booking b  (cost=0.00..107761.06 rows=133286 width=8) (actual time=378.084..7813.799 rows=105557 loops=5)
                           Filter: ((update_ts >= '2020-04-30'::date) AND (update_ts <= '2020-05-12'::date))
                           Rows Removed by Filter: 1023086
                     ->  Parallel Hash  (cost=176305.14..176305.14 rows=4473414 width=8) (actual time=7828.022..7828.027 rows=3578713 loops=5)
                           Buckets: 65536  Batches: 512  Memory Usage: 1952kB
                           ->  Parallel Seq Scan on booking_leg bl  (cost=0.00..176305.14 rows=4473414 width=8) (actual time=2.173..4994.703 rows=3578713 loops=5)
               ->  Parallel Hash  (cost=11413.57..11413.57 rows=284657 width=8) (actual time=8632.807..8632.808 rows=136635 loops=5)
                     Buckets: 65536  Batches: 32  Memory Usage: 1568kB
                     ->  Parallel Seq Scan on flight f  (cost=0.00..11413.57 rows=284657 width=8) (actual time=1.324..1925.596 rows=136635 loops=5)
         ->  Parallel Hash  (cost=212433.62..212433.62 rows=4078562 width=20) (actual time=9950.436..9950.447 rows=3262739 loops=5)
               Buckets: 65536  Batches: 1024  Memory Usage: 1440kB
               ->  Parallel Seq Scan on passenger p  (cost=0.00..212433.62 rows=4078562 width=20) (actual time=212.412..4073.229 rows=3262739 loops=5)
 Planning Time: 23.485 ms
 JIT:
   Functions: 140
   Options: Inlining true, Optimization true, Expressions true, Deforming true
   Timing: Generation 7.480 ms, Inlining 322.948 ms, Optimization 446.935 ms, Emission 297.963 ms, Total 1075.327 ms
 Execution Time: 96104.680 ms
(27 rows)
```
- Планируемое время сократилось, а фактическое составило - Query complete 00:00:46.432
- Добавим индексы для полей, по которым осуществляется связь таблиц
```postgresql
create index passenger_booking_id_idx on postgres_air.passenger(booking_id);
create index booking_leg_booking_id_idx on  postgres_air.booking_leg(booking_id);
create index booking_leg_flight_id_idx on  postgres_air.booking_leg(flight_id);
create index flight_flight_id_idx on postgres_air.flight(flight_id);
create index booking_booking_id_idx on postgres_air.booking(booking_id);
```
- Смотрим план:
```postgresql
 Gather  (cost=554091.61..1211722.32 rows=4886970 width=20) (actual time=78540.365..185134.503 rows=4810062 loops=1)
   Workers Planned: 4
   Workers Launched: 4
   ->  Parallel Hash Left Join  (cost=553091.61..722025.32 rows=1221742 width=20) (actual time=81246.209..124256.717 rows=962012 loops=5)
         Hash Cond: (b.booking_id = p.booking_id)
         ->  Parallel Hash Left Join  (cost=265781.09..400464.76 rows=422624 width=12) (actual time=37446.428..37507.408 rows=332654 loops=5)
               Hash Cond: (bl.flight_id = f.flight_id)
               ->  Parallel Hash Left Join  (cost=249697.32..378031.58 rows=422624 width=12) (actual time=33070.310..33611.280 rows=332654 loops=5)
                     Hash Cond: (b.booking_id = bl.booking_id)
                     ->  Parallel Seq Scan on booking b  (cost=0.00..107761.06 rows=133286 width=8) (actual time=1954.592..3082.357 rows=105557 loops=5)
                           Filter: ((update_ts >= '2020-04-30'::date) AND (update_ts <= '2020-05-12'::date))
                           Rows Removed by Filter: 1023086
                     ->  Parallel Hash  (cost=176304.92..176304.92 rows=4473392 width=8) (actual time=24656.842..24656.844 rows=3578713 loops=5)
                           Buckets: 65536  Batches: 512  Memory Usage: 1952kB
                           ->  Parallel Seq Scan on booking_leg bl  (cost=0.00..176304.92 rows=4473392 width=8) (actual time=1.968..15000.388 rows=3578713 loops=5)
               ->  Parallel Hash  (cost=11413.57..11413.57 rows=284657 width=8) (actual time=3777.098..3777.101 rows=136635 loops=5)
                     Buckets: 65536  Batches: 32  Memory Usage: 1536kB
                     ->  Parallel Seq Scan on flight f  (cost=0.00..11413.57 rows=284657 width=8) (actual time=1.416..857.927 rows=136635 loops=5)
         ->  Parallel Hash  (cost=212432.23..212432.23 rows=4078423 width=20) (actual time=35214.585..35214.732 rows=3262739 loops=5)
               Buckets: 65536  Batches: 1024  Memory Usage: 1472kB
               ->  Parallel Seq Scan on passenger p  (cost=0.00..212432.23 rows=4078423 width=20) (actual time=281.490..10034.753 rows=3262739 loops=5)
 Planning Time: 25.610 ms
 JIT:
   Functions: 140
   Options: Inlining true, Optimization true, Expressions true, Deforming true
   Timing: Generation 13.005 ms, Inlining 567.788 ms, Optimization 513.100 ms, Emission 323.483 ms, Total 1417.377 ms
 Execution Time: 185335.546 ms
(27 rows)
```
- Планируемое время стало чуть хуже, а фактическое составило - Query complete 00:01:20.321
- Самое странное, что план не строится по индексам
- Попробуем заменить LEFT JOIN на прямое соединение
```postgresql
postgres_air=# explain analyze select p.passenger_id as "Идентификатор пассажира",
                                      p.first_name   as "Имя",
                                      p.last_name    as "Фамилия",
                                      f.flight_no    as "Номер самолета"
                               from postgres_air.booking as b, 
                                                                        postgres_air.passenger as p, 
                                                                        postgres_air.booking_leg as bl, 
                                                                        postgres_air.flight as f
                               where b.update_ts between '2020-04-30'::date and '2020-05-12'::date 
                                                                                and p.booking_id = b.booking_id 
                                                                                and b.booking_id = bl.booking_id 
                                                                                and bl.flight_id = f.flight_id;
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather  (cost=364246.69..1133584.37 rows=4886970 width=20) (actual time=82577.792..88645.789 rows=4810062 loops=1)
   Workers Planned: 4
   Workers Launched: 4
   ->  Parallel Hash Join  (cost=363246.69..643887.37 rows=1221742 width=20) (actual time=82548.592..84200.376 rows=962012 loops=5)
         Hash Cond: (p.booking_id = b.booking_id)
         ->  Parallel Seq Scan on passenger p  (cost=0.00..212432.23 rows=4078423 width=20) (actual time=1.091..12732.993 rows=3262739 loops=5)
         ->  Parallel Hash  (cost=355899.89..355899.89 rows=422624 width=16) (actual time=53020.542..53020.548 rows=332654 loops=5)
               Buckets: 65536  Batches: 64  Memory Usage: 1984kB
               ->  Parallel Hash Join  (cost=126031.91..355899.89 rows=422624 width=16) (actual time=52891.931..52962.041 rows=332654 loops=5)
                     Hash Cond: (bl.flight_id = f.flight_id)
                     ->  Parallel Hash Join  (cost=109948.13..333466.72 rows=422624 width=16) (actual time=49863.841..50130.918 rows=332654 loops=5)
                           Hash Cond: (bl.booking_id = b.booking_id)
                           ->  Parallel Seq Scan on booking_leg bl  (cost=0.00..176304.92 rows=4473392 width=8) (actual time=0.069..5413.382 rows=3578713 loops=5)
                           ->  Parallel Hash  (cost=107761.06..107761.06 rows=133286 width=8) (actual time=30329.525..30329.526 rows=105557 loops=5)
                                 Buckets: 65536  Batches: 16  Memory Usage: 1888kB
                                 ->  Parallel Seq Scan on booking b  (cost=0.00..107761.06 rows=133286 width=8) (actual time=1275.222..7718.907 rows=105557 loops=5)
                                       Filter: ((update_ts >= '2020-04-30'::date) AND (update_ts <= '2020-05-12'::date))
                                       Rows Removed by Filter: 1023086
                     ->  Parallel Hash  (cost=11413.57..11413.57 rows=284657 width=8) (actual time=2697.424..2697.425 rows=136635 loops=5)
                           Buckets: 65536  Batches: 32  Memory Usage: 1568kB
                           ->  Parallel Seq Scan on flight f  (cost=0.00..11413.57 rows=284657 width=8) (actual time=187.196..891.884 rows=136635 loops=5)
 Planning Time: 37.576 ms
 JIT:
   Functions: 140
   Options: Inlining true, Optimization true, Expressions true, Deforming true
   Timing: Generation 7.948 ms, Inlining 358.002 ms, Optimization 343.196 ms, Emission 232.220 ms, Total 941.367 ms
 Execution Time: 88805.739 ms
(27 rows)
```
- Планируемое время стало больше, но реальное время выполнения по сути не изменилось - Query complete 00:00:45.081 -  но время выполнения стабильно на 1 секунду быстрее.
- Попробуем секционировать booking
```postgresql
postgres_air=# select min(update_ts), max(update_ts) from postgres_air.booking;
              min              |             max              
-------------------------------+------------------------------
 2020-03-10 08:38:00.114908+05 | 2020-08-18 08:08:30.30921+05
 
 
create table postgres_air.partition_booking (like postgres_air.booking) partition by range (update_ts);

create table postgres_air.partition_booking_2020_03 partition of postgres_air.partition_booking for values from ('2020-03-01') to ('2020-04-01');
create table postgres_air.partition_booking_2020_04 partition of postgres_air.partition_booking for values from ('2020-04-01') to ('2020-05-01');
create table postgres_air.partition_booking_2020_05 partition of postgres_air.partition_booking for values from ('2020-05-01') to ('2020-06-01');
create table postgres_air.partition_booking_2020_06 partition of postgres_air.partition_booking for values from ('2020-06-01') to ('2020-07-01');
create table postgres_air.partition_booking_2020_07 partition of postgres_air.partition_booking for values from ('2020-07-01') to ('2020-08-01');
create table postgres_air.partition_booking_2020_08 partition of postgres_air.partition_booking for values from ('2020-08-01') to ('2020-09-01');
create table postgres_air.partition_booking_2020_09 partition of postgres_air.partition_booking for values from ('2020-09-01') to ('2020-10-01');
create table postgres_air.partition_booking_2020_10 partition of postgres_air.partition_booking for values from ('2020-10-01') to ('2020-11-01');

insert into postgres_air.partition_booking (select * from postgres_air.booking);
```
- План запроса 
```postgresql
postgres_air=# explain analyze select p.passenger_id as "Идентификатор пассажира",
                                      p.first_name   as "Имя",
                                      p.last_name    as "Фамилия",
                                      f.flight_no    as "Номер самолета"
                               from postgres_air.partition_booking as b, 
                                                                        postgres_air.passenger as p, 
                                                                        postgres_air.booking_leg as bl, 
                                                                        postgres_air.flight as f
                               where b.update_ts between '2020-04-30'::date and '2020-05-12'::date 
                                                                                and p.booking_id = b.booking_id 
                                                                                and b.booking_id = bl.booking_id 
                                                                                and bl.flight_id = f.flight_id;
                                                                                  QUERY PLAN                                                                                  
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=1025717.93..2324496.12 rows=47002493 width=20) (actual time=35181.753..55736.801 rows=4810062 loops=1)
   Hash Cond: (bl.booking_id = p.booking_id)
   ->  Hash Join  (cost=26607.46..526548.02 rows=17893566 width=8) (actual time=582.317..19136.646 rows=17893566 loops=1)
         Hash Cond: (bl.flight_id = f.flight_id)
         ->  Seq Scan on booking_leg bl  (cost=0.00..310506.66 rows=17893566 width=8) (actual time=359.707..12753.934 rows=17893566 loops=1)
         ->  Hash  (cost=15398.76..15398.76 rows=683176 width=8) (actual time=220.233..220.234 rows=683176 loops=1)
               Buckets: 65536  Batches: 32  Memory Usage: 1414kB
               ->  Seq Scan on flight f  (cost=0.00..15398.76 rows=683176 width=8) (actual time=0.760..125.678 rows=683176 loops=1)
   ->  Hash  (cost=907323.67..907323.67 rows=4746944 width=28) (actual time=31105.788..31477.136 rows=1537239 loops=1)
         Buckets: 32768  Batches: 256  Memory Usage: 624kB
         ->  Gather  (cost=288310.52..907323.67 rows=4746944 width=28) (actual time=30376.528..30948.827 rows=1537239 loops=1)
               Workers Planned: 4
               Workers Launched: 4
               ->  Parallel Hash Join  (cost=287310.52..431629.27 rows=1186736 width=28) (actual time=30312.819..30561.901 rows=307448 loops=5)
                     Hash Cond: (b.booking_id = p.booking_id)
                     ->  Parallel Append  (cost=0.00..115439.88 rows=131462 width=8) (actual time=37.732..1226.843 rows=105557 loops=5)
                           Subplans Removed: 6
                           ->  Parallel Seq Scan on partition_booking_2020_04 b_1  (cost=0.00..26469.55 rows=12649 width=8) (actual time=37.585..1094.246 rows=8983 loops=5)
                                 Filter: ((update_ts >= '2020-04-30'::date) AND (update_ts <= '2020-05-12'::date))
                                 Rows Removed by Filter: 253299
                           ->  Parallel Seq Scan on partition_booking_2020_05 b_2  (cost=0.00..12128.28 rows=156974 width=8) (actual time=0.674..210.889 rows=160956 loops=3)
                                 Filter: ((update_ts >= '2020-04-30'::date) AND (update_ts <= '2020-05-12'::date))
                                 Rows Removed by Filter: 39323
                     ->  Parallel Hash  (cost=212432.23..212432.23 rows=4078423 width=20) (actual time=26327.430..26327.433 rows=3262739 loops=5)
                           Buckets: 65536  Batches: 1024  Memory Usage: 1504kB
                           ->  Parallel Seq Scan on passenger p  (cost=0.00..212432.23 rows=4078423 width=20) (actual time=176.974..11672.537 rows=3262739 loops=5)
 Planning Time: 1.689 ms
 JIT:
   Functions: 96
   Options: Inlining true, Optimization true, Expressions true, Deforming true
   Timing: Generation 5.220 ms, Inlining 334.209 ms, Optimization 503.892 ms, Emission 399.955 ms, Total 1243.275 ms
 Execution Time: 56161.134 ms
(32 rows)
```
- А время исполнения - Query complete 00:00:46.017
- В итоге после доительного перерыва перед самой защитой заметил, что составил не корректно запрос, вот так было бы коректнее:
```postgresql
with t1 as (
	select b.booking_id, p.passenger_id, p.first_name, p.last_name
                       from postgres_air.passenger as p left join postgres_air.booking as b on p.booking_id = b.booking_id
                       WHERE b.update_ts between '2020-04-30'::date and '2020-05-12'::date
),
	t2 as (
	select b.booking_id, f.flight_no, ROW_NUMBER() OVER(PARTITION BY b.booking_id) AS rownum
				from postgres_air.booking as b left join postgres_air.booking_leg as bl on b.booking_id = bl.booking_id
						left join postgres_air.flight as f on bl.flight_id = f.flight_id
                               where b.update_ts between '2020-04-30'::date and '2020-05-12'::date
)
select t1.passenger_id, t1.first_name, t1.last_name, t2.flight_no from t1, t2 where t1.booking_id = t2.booking_id and t2.rownum = 1;

QUERY PLAN                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=365375.70..633454.54 rows=7208 width=20) (actual time=1789.076..5473.116 rows=1537239 loops=1)
   ->  Nested Loop  (cost=365375.26..631874.47 rows=799 width=20) (actual time=1788.977..3502.106 rows=527785 loops=1)
         ->  Subquery Scan on t2  (cost=365374.83..611859.91 rows=8452 width=12) (actual time=1788.916..2568.305 rows=527785 loops=1)
               Filter: (t2.rownum = 1)
               ->  WindowAgg  (cost=365374.83..590728.72 rows=1690495 width=20) (actual time=1788.913..2528.160 rows=527785 loops=1)
                     Run Condition: (row_number() OVER (?) <= 1)
                     ->  Gather Merge  (cost=365374.83..565371.29 rows=1690495 width=12) (actual time=1788.859..2132.054 rows=1663268 loops=1)
                           Workers Planned: 3
                           Workers Launched: 3
                           ->  Sort  (cost=364374.79..365738.09 rows=545321 width=12) (actual time=1761.665..1804.317 rows=415817 loops=4)
                                 Sort Key: b_1.booking_id
                                 Sort Method: external merge  Disk: 9104kB
                                 Worker 0:  Sort Method: external merge  Disk: 9192kB
                                 Worker 1:  Sort Method: external merge  Disk: 9168kB
                                 Worker 2:  Sort Method: external merge  Disk: 9696kB
                                 ->  Parallel Hash Left Join  (cost=16084.65..301496.27 rows=545321 width=12) (actual time=1564.554..1631.474 rows=415817 loops=4)
                                       Hash Cond: (bl.flight_id = f.flight_id)
                                       ->  Nested Loop Left Join  (cost=0.87..277543.01 rows=545321 width=12) (actual time=0.440..1147.352 rows=415817 loops=4)
                                             ->  Parallel Index Scan using booking_update_ts_idx on booking b_1  (cost=0.43..82711.29 rows=171982 width=8) (actual time=0.318..292.469 rows=131946 loops=4)
                                                   Index Cond: ((update_ts >= '2020-04-30'::date) AND (update_ts <= '2020-05-12'::date))
                                             ->  Index Scan using booking_leg_booking_id_idx on booking_leg bl  (cost=0.44..1.00 rows=13 width=8) (actual time=0.005..0.006 rows=3 loops=527785)
                                                   Index Cond: (booking_id = b_1.booking_id)
                                       ->  Parallel Hash  (cost=11413.57..11413.57 rows=284657 width=8) (actual time=294.160..294.161 rows=170794 loops=4)
                                             Buckets: 65536  Batches: 32  Memory Usage: 1568kB
                                             ->  Parallel Seq Scan on flight f  (cost=0.00..11413.57 rows=284657 width=8) (actual time=187.418..254.778 rows=170794 loops=4)
         ->  Index Scan using booking_booking_id_idx on booking b  (cost=0.43..2.37 rows=1 width=8) (actual time=0.001..0.001 rows=1 loops=527785)
               Index Cond: (booking_id = t2.booking_id)
               Filter: ((update_ts >= '2020-04-30'::date) AND (update_ts <= '2020-05-12'::date))
   ->  Index Scan using passenger_booking_id_idx on passenger p  (cost=0.43..1.89 rows=9 width=20) (actual time=0.002..0.003 rows=3 loops=527785)
         Index Cond: (booking_id = b.booking_id)
 Planning Time: 22.209 ms
 JIT:
   Functions: 81
   Options: Inlining true, Optimization true, Expressions true, Deforming true
   Timing: Generation 5.179 ms, Inlining 283.116 ms, Optimization 274.607 ms, Emission 192.078 ms, Total 754.980 ms
 Execution Time: 5570.605 ms
(36 rows)
```
- Фактическое время выполнения уменьшилось до Query complete 00:00:06.390
